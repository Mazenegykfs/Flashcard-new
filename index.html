
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive English Flashcards</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
    
    <!-- Babel for in-browser JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- React and ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.client.js"></script>
    
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      }
      .btn {
          display: flex;
          align-items: center;
          justify-content: center;
          gap: 0.5rem;
          padding: 0.75rem 1.5rem;
          font-size: 1.125rem;
          line-height: 1.75rem;
          font-weight: 700;
          color: white;
          border-radius: 9999px;
          box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
          transition-property: all;
          transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
          transition-duration: 150ms;
      }
      .btn:hover:not(:disabled) {
           transform: translateY(-0.25rem);
      }
      .btn:disabled {
          opacity: 0.5;
          cursor: not-allowed;
      }
      .btn-quiz, .btn-game {
          width: 100%;
          display: flex;
          align-items: center;
          justify-content: center;
          gap: 0.5rem;
          padding: 1rem 1.5rem;
          font-size: 1.25rem;
          line-height: 1.75rem;
          font-weight: 700;
          color: white;
          border-radius: 9999px;
          box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
          transition: all 0.2s;
      }
       .btn-quiz:hover:not(:disabled), .btn-game:hover:not(:disabled) {
           opacity: 0.9;
           transform: translateY(-0.25rem);
       }
      .match-item {
          padding: 1rem;
          font-size: 1.125rem;
          font-weight: 600;
          border-width: 2px;
          border-color: #e5e7eb;
          border-radius: 0.5rem;
          cursor: pointer;
          transition: all 0.2s;
          background-color: white;
      }
      .match-item:hover {
          background-color: #e0f2fe;
          border-color: #60a5fa;
      }
      .match-item.selected {
          background-color: #bfdbfe;
          border-color: #3b82f6;
          box-shadow: 0 0 0 2px #3b82f6;
      }
      .match-item.correct {
          background-color: #22c55e;
          color: white;
          border-color: #22c55e;
          cursor: not-allowed;
      }
      .match-item.incorrect {
          background-color: #ef4444;
          color: white;
          border-color: #ef4444;
      }
      .perspective-1000 { perspective: 1000px; }
      .transform-style-3d { transform-style: preserve-3d; }
      .backface-hidden { -webkit-backface-visibility: hidden; backface-visibility: hidden; }
      .rotate-y-180 { transform: rotateY(180deg); }
      .hg-part {
          stroke: #212529;
          stroke-width: 4;
          fill: none;
          stroke-linecap: round;
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0"
  }
}
</script>
</head>
  <body class="bg-[#e0f7fa]">
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useCallback, useEffect, useMemo } = React;

      // --- All Components Bundled ---

      // from: components/icons.tsx
      const BookOpenIcon = () => (
          <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
          </svg>
      );
      const SearchIcon = () => (
          <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
          </svg>
      );
      const QuizIcon = () => (
          <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
      );
      const GamepadIcon = () => (
          <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 17a1 1 0 001.447.894l4-2A1 1 0 0017 15V9.236a1 1 0 00-1.447-.894l-4 2a1 1 0 00-.553.894V17zM15.21 18.506A9.952 9.952 0 0112 19c-5.523 0-10-4.477-10-10S6.477 2 12 2s10 4.477 10 10c0 .963-.138 1.898-.404 2.766" />
          </svg>
      );
      const SpinnerIcon = () => (
          <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
      );
      const PronounceIcon = () => (
          <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
          </svg>
      );
      const PrevIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" /></svg>;
      const NextIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" /></svg>;
      const ShuffleIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-6 6-4-4-6 6m12 5l6-6" /></svg>;
      const AutoplayIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>;
      const StopIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 10h6v4H9z" /></svg>;
      const RestartIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h5M20 20v-5h-5" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 9a9 9 0 0114.13-4.13M20 15a9 9 0 01-14.13 4.13" /></svg>;
      const ScoreIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" /></svg>;

      // from: components/HangmanDrawing.tsx
      const HangmanDrawing = ({ numberOfGuesses }) => {
          const Head = <circle cx="140" cy="70" r="20" />;
          const Body = <line x1="140" y1="90" x2="140" y2="130" />;
          const RightArm = <line x1="140" y1="100" x2="170" y2="120" />;
          const LeftArm = <line x1="140" y1="100" x2="110" y2="120" />;
          const RightLeg = <line x1="140" y1="130" x2="170" y2="150" />;
          const LeftLeg = <line x1="140" y1="130" x2="110" y2="150" />;
          const BODY_PARTS = [Head, Body, RightArm, LeftArm, RightLeg, LeftLeg];

          return (
              <svg viewBox="0 0 200 250" className="w-40 h-52 mx-auto">
                  <line className="hg-part" x1="20" y1="230" x2="100" y2="230" /> 
                  <line className="hg-part" x1="60" y1="230" x2="60" y2="20" />
                  <line className="hg-part" x1="60" y1="20" x2="140" y2="20" />
                  <line className="hg-part" x1="140" y1="20" x2="140" y2="50" />
                  {BODY_PARTS.slice(0, numberOfGuesses).map((part, index) => (
                      <g key={index} className="hg-part">
                          {part}
                      </g>
                  ))}
              </svg>
          );
      }
      
      // from: components/Notification.tsx
      const Notification = ({ notification, onClear }) => {
          const [isVisible, setIsVisible] = useState(false);

          useEffect(() => {
              if (notification) {
                  setIsVisible(true);
                  const timer = setTimeout(() => {
                      setIsVisible(false);
                      setTimeout(onClear, 400); 
                  }, 3000);
                  return () => clearTimeout(timer);
              }
          }, [notification, onClear]);

          if (!notification) return null;

          const baseClasses = "fixed top-5 right-5 p-4 rounded-lg shadow-lg text-white text-lg flex items-center gap-3 z-50 transition-transform duration-400 ease-in-out";
          const colorClasses = notification.isError ? "bg-red-500" : "bg-green-500";
          const transformClasses = isVisible ? "translate-x-0" : "translate-x-[120%]";

          return (
              <div className={`${baseClasses} ${colorClasses} ${transformClasses}`}>
                  <span>{notification.isError ? '❌' : '✅'}</span>
                  <p>{notification.message}</p>
              </div>
          );
      };
      
      // from: components/FileLoader.tsx
      const FileLoader = ({ onCardsLoaded, showNotification }) => {
          const [fileList, setFileList] = useState([]);
          const [selectedFile, setSelectedFile] = useState('');
          const [isLoading, setIsLoading] = useState(true);
          const GITHUB_REPO_URL = 'https://api.github.com/repos/Mazenegykfs/Flashcards/contents/';

          const fetchFileList = useCallback(async () => {
              try {
                  const response = await fetch(GITHUB_REPO_URL);
                  if (!response.ok) throw new Error('Could not fetch file list from GitHub.');
                  const files = await response.json();
                  const excelFiles = files
                      .filter(file => file.name.endsWith('.xlsx'))
                      .sort((a, b) => a.name.localeCompare(b.name));
                  if (excelFiles.length === 0) throw new Error('No .xlsx files found in the GitHub repository.');
                  setFileList(excelFiles);
                  setSelectedFile(excelFiles[0].name);
              } catch (error) {
                  const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
                  showNotification(errorMessage, true);
              } finally {
                  setIsLoading(false);
              }
          }, [showNotification]);

          useEffect(() => {
              fetchFileList();
          }, [fetchFileList]);

          const loadDataFromUrl = useCallback(async (url) => {
              setIsLoading(true);
              try {
                  const response = await fetch(url);
                  if (!response.ok) throw new Error(`Network response error: ${response.statusText}`);
                  const data = await response.arrayBuffer();
                  
                  const workbook = window.XLSX.read(data, { type: 'array' });
                  const sheetName = workbook.SheetNames[0];
                  const worksheet = workbook.Sheets[sheetName];
                  const jsonData = window.XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                  const headers = jsonData[0].map(h => String(h).toLowerCase().trim());
                  const wordIndex = headers.indexOf('word');
                  const iconIndex = headers.indexOf('icon');
                  const descIndex = headers.indexOf('description');
                  const arabicIndex = headers.indexOf('arabic meaning');
                  
                  if (wordIndex === -1) throw new Error("Column 'Word' not found.");

                  const loadedFlashcards = jsonData.slice(1).map(row => ({
                      word: (row[wordIndex] || '').toString(), 
                      icon: row[iconIndex], 
                      description: row[descIndex], 
                      arabicMeaning: row[arabicIndex]
                  })).filter(card => card.word && card.arabicMeaning && /^[a-zA-Z\s'-]+$/.test(card.word));

                  if (loadedFlashcards.length < 8) {
                      throw new Error("At least 8 valid English words with Arabic meanings are needed for games and quizzes.");
                  }
                  onCardsLoaded(loadedFlashcards);
              } catch (error) {
                  const errorMessage = error instanceof Error ? error.message : 'Failed to load or process file';
                  showNotification(errorMessage, true);
                  onCardsLoaded([]);
              } finally {
                  setIsLoading(false);
              }
          }, [onCardsLoaded, showNotification]);
          
          const handleLoadClick = () => {
              const file = fileList.find(f => f.name === selectedFile);
              if (file) {
                  const fileUrl = `https://raw.githubusercontent.com/Mazenegykfs/Flashcards/main/${file.name}`;
                  loadDataFromUrl(fileUrl);
              }
          };

          if (isLoading && fileList.length === 0) {
              return (
                  <div className="flex flex-col items-center justify-center p-4">
                      <SpinnerIcon />
                      <p>Loading file list from GitHub...</p>
                  </div>
              );
          }

          return (
              <div>
                  <h2 className="text-2xl font-bold mb-4">Select a Word List</h2>
                  <div className="flex flex-col sm:flex-row gap-4 justify-center items-center">
                      <select 
                          id="fileSelect" 
                          value={selectedFile}
                          onChange={(e) => setSelectedFile(e.target.value)}
                          className="w-full sm:w-auto px-4 py-3 text-lg border-2 border-[#4cc9f0] rounded-lg focus:ring-2 focus:ring-[#4361ee] focus:border-[#4361ee] transition"
                          disabled={isLoading}
                      >
                          {fileList.map(file => <option key={file.name} value={file.name}>{file.name}</option>)}
                      </select>
                      <button 
                          onClick={handleLoadClick}
                          className="w-full sm:w-auto flex items-center justify-center gap-2 px-6 py-3 text-lg font-bold text-white bg-[#67cbf3] rounded-full shadow-md hover:bg-[#4361ee] transition-transform transform hover:-translate-y-1 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
                          disabled={isLoading}
                      >
                          {isLoading ? <SpinnerIcon /> : '📚'}
                          {isLoading ? 'Loading...' : 'Load Cards'}
                      </button>
                  </div>
              </div>
          );
      };

      // from: components/MemorizeView.tsx
      const FlashcardDisplay = ({ cardData, isFlipped, onFlip, onPronounce }) => {
          const colorMap = {
              'red': '#ff0000', 'green': '#008000', 'blue': '#0000ff', 'yellow': '#ffff00',
              'orange': '#ffa500', 'purple': '#800080', 'pink': '#ffc0cb', 'black': '#000000',
              'white': '#ffffff', 'gray': '#808080', 'grey': '#808080', 'brown': '#a52a2a',
          };
          const wordLower = (cardData.word || '').toLowerCase();
          const iconColor = colorMap[wordLower];
          const iconStyle = {
              color: iconColor || 'inherit',
              textShadow: wordLower === 'white' ? '0 0 5px #000' : 'none'
          };
          return (
              <div className="h-[400px] perspective-1000 mb-8" onClick={onFlip}>
                  <div className={`relative w-full h-full transform-style-3d transition-transform duration-700 rounded-2xl shadow-xl cursor-pointer ${isFlipped ? 'rotate-y-180' : ''}`}>
                      <div className="absolute w-full h-full backface-hidden rounded-2xl p-8 flex flex-col justify-center items-center text-center bg-gradient-to-br from-[#81d4fa] to-[#4fc3f7] text-white">
                          <div className="text-6xl mb-5" style={iconStyle}>{cardData.icon || '📝'}</div>
                          <div className="flex items-center gap-4">
                              <div className="text-4xl font-bold">{cardData.word}</div>
                              <button onClick={onPronounce} className="text-4xl transition-transform hover:scale-110 p-0 leading-none">
                                 <PronounceIcon />
                              </button>
                          </div>
                      </div>
                      <div className="absolute w-full h-full backface-hidden rounded-2xl p-8 flex flex-col justify-center items-center text-center bg-gradient-to-br from-[#f1f8e9] to-[#dcedc8] text-[#212529] rotate-y-180 overflow-y-auto">
                          <p className="text-xl mb-4">{cardData.description || 'No description available.'}</p>
                          <p className="text-3xl font-bold text-[#4361ee] font-['Tahoma']" dir="rtl">{cardData.arabicMeaning}</p>
                      </div>
                  </div>
              </div>
          );
      };
      const PronunciationControls = ({ rate, setRate, pronounceWord, setPronounceWord, pronounceArabic, setPronounceArabic, pronounceDescription, setPronounceDescription }) => {
          return (
              <div className="flex flex-wrap justify-center items-center gap-x-8 gap-y-4 bg-gray-50 p-4 rounded-lg mb-5">
                  <div className="flex items-center gap-2">
                      <label htmlFor="speedControl" className="font-bold">Voice Speed:</label>
                      <input type="range" id="speedControl" min="0.5" max="2" value={rate} step="0.1" onChange={e => setRate(parseFloat(e.target.value))} className="w-36"/>
                      <span className="font-bold text-[#4361ee] min-w-[40px]">{rate.toFixed(1)}x</span>
                  </div>
                  <div className="flex items-center gap-4">
                      <strong className="mr-2">Pronounce:</strong>
                      <label className="flex items-center gap-1 cursor-pointer"><input type="checkbox" checked={pronounceWord} onChange={e => setPronounceWord(e.target.checked)} /> Word</label>
                      <label className="flex items-center gap-1 cursor-pointer"><input type="checkbox" checked={pronounceArabic} onChange={e => setPronounceArabic(e.target.checked)} /> Arabic</label>
                      <label className="flex items-center gap-1 cursor-pointer"><input type="checkbox" checked={pronounceDescription} onChange={e => setPronounceDescription(e.target.checked)} /> Description</label>
                  </div>
              </div>
          );
      };
      const MemorizeView = ({ cards, setCards, showNotification }) => {
          const [currentIndex, setCurrentIndex] = useState(0);
          const [isFlipped, setIsFlipped] = useState(false);
          const [isAutoplaying, setIsAutoplaying] = useState(false);
          const [speechRate, setSpeechRate] = useState(1.0);
          const [pronounceWord, setPronounceWord] = useState(true);
          const [pronounceArabic, setPronounceArabic] = useState(false);
          const [pronounceDescription, setPronounceDescription] = useState(false);
          const currentCard = useMemo(() => cards[currentIndex], [cards, currentIndex]);

          const pronounceText = useCallback((text, lang, rate) => {
              return new Promise(resolve => {
                  if (!text || !('speechSynthesis' in window)) {
                      resolve();
                      return;
                  }
                  const utterance = new SpeechSynthesisUtterance(text);
                  utterance.lang = lang;
                  utterance.rate = rate;
                  utterance.onend = () => resolve();
                  utterance.onerror = () => resolve();
                  window.speechSynthesis.speak(utterance);
              });
          }, []);

          const showNextCard = useCallback(() => {
              setIsFlipped(false);
              setCurrentIndex(prev => (prev + 1) % cards.length);
          }, [cards.length]);

          const showPrevCard = () => {
              setIsFlipped(false);
              setCurrentIndex(prev => (prev - 1 + cards.length) % cards.length);
          };

          const shuffleCards = () => {
              if (cards.length < 2) {
                  showNotification("Not enough cards to shuffle.", true);
                  return;
              }
              const shuffled = [...cards].sort(() => Math.random() - 0.5);
              setCards(shuffled);
              setCurrentIndex(0);
              setIsFlipped(false);
              showNotification("🔀 Cards have been shuffled!");
          };
          
          const stopAutoplay = useCallback(() => {
              setIsAutoplaying(false);
              window.speechSynthesis.cancel();
          }, []);
          
          const handleFlip = async () => {
              if (isAutoplaying) return;
              const newFlippedState = !isFlipped;
              setIsFlipped(newFlippedState);
              if (newFlippedState) {
                  if (pronounceArabic && currentCard.arabicMeaning) await pronounceText(currentCard.arabicMeaning, 'ar-SA', speechRate);
                  if (pronounceDescription && currentCard.description) await pronounceText(currentCard.description, 'en-US', speechRate);
              } else {
                  window.speechSynthesis.cancel();
              }
          };
          
          const handlePronounce = (e) => {
              e.stopPropagation();
              if (pronounceWord && currentCard.word) {
                  pronounceText(currentCard.word, 'en-US', speechRate);
              }
          };
          
          const handleWordListItemClick = (index) => {
              stopAutoplay();
              setCurrentIndex(index);
              setIsFlipped(false);
          };

          useEffect(() => {
              if (!isAutoplaying) return;
              let cancelled = false;
              const sequence = async () => {
                  if (pronounceWord && currentCard.word) await pronounceText(currentCard.word, 'en-US', speechRate);
                  if (cancelled) return;
                  await new Promise(r => setTimeout(r, 500));
                  if (cancelled) return;
                  setIsFlipped(true);
                  await new Promise(r => setTimeout(r, 800));
                  if (cancelled) return;
                  if (pronounceArabic && currentCard.arabicMeaning) await pronounceText(currentCard.arabicMeaning, 'ar-SA', speechRate);
                  if (cancelled) return;
                  if (pronounceDescription && currentCard.description) await pronounceText(currentCard.description, 'en-US', speechRate);
                  if (cancelled) return;
                  await new Promise(r => setTimeout(r, 1500));
                  if (cancelled) return;
                  showNextCard();
              };
              const timeoutId = setTimeout(sequence, 800);
              return () => {
                  cancelled = true;
                  clearTimeout(timeoutId);
              };
          }, [isAutoplaying, currentIndex, showNextCard, currentCard, pronounceText, speechRate, pronounceWord, pronounceArabic, pronounceDescription]);
          
          useEffect(() => {
              return () => stopAutoplay();
          }, [stopAutoplay]);

          return (
              <div className="bg-white p-6 rounded-2xl shadow-md">
                  <PronunciationControls 
                      rate={speechRate} setRate={setSpeechRate}
                      pronounceWord={pronounceWord} setPronounceWord={setPronounceWord}
                      pronounceArabic={pronounceArabic} setPronounceArabic={setPronounceArabic}
                      pronounceDescription={pronounceDescription} setPronounceDescription={setPronounceDescription}
                  />
                  <FlashcardDisplay 
                      cardData={currentCard} 
                      isFlipped={isFlipped}
                      onFlip={handleFlip}
                      onPronounce={handlePronounce}
                  />
                  <div className="flex justify-between items-center flex-wrap gap-2">
                      <button onClick={showPrevCard} disabled={isAutoplaying} className="btn bg-[#f44336]"><PrevIcon/> Previous</button>
                      <div className="font-bold text-lg">{currentIndex + 1} / {cards.length}</div>
                      <div className="flex gap-2">
                          <button onClick={shuffleCards} disabled={isAutoplaying} className="btn bg-[#4361ee]"><ShuffleIcon /> Shuffle</button>
                          <button onClick={() => setIsAutoplaying(!isAutoplaying)} className={`btn ${isAutoplaying ? 'bg-[#f72585]' : 'bg-[#4cc9f0]'}`}>
                              {isAutoplaying ? <><StopIcon/> Stop</> : <><AutoplayIcon/> Autoplay</>}
                          </button>
                      </div>
                      <button onClick={showNextCard} disabled={isAutoplaying} className="btn bg-[#67cbf3]"><NextIcon /> Next</button>
                  </div>
                  <div className="mt-5 max-h-40 overflow-y-auto border border-gray-200 rounded-lg p-2">
                      {cards.map((card, index) => (
                          <div
                              key={`${card.word}-${index}`}
                              className={`p-2.5 rounded-md cursor-pointer transition-colors ${currentIndex === index ? 'bg-[#4361ee] text-white font-bold' : 'hover:bg-blue-100'}`}
                              onClick={() => handleWordListItemClick(index)}
                          >
                              {card.word}
                          </div>
                      ))}
                  </div>
              </div>
          );
      };

      // from: components/SearchView.tsx
      const SearchResultCard = ({ card }) => {
          if (!card) {
              return (
                  <div className="h-[250px] rounded-2xl p-8 flex flex-col justify-center items-center text-center bg-gradient-to-br from-gray-200 to-gray-300">
                      <div className="text-6xl mb-5">🔍</div>
                      <h3 className="text-2xl font-bold text-gray-700">Search for a Word</h3>
                      <p className="text-gray-600 mt-2">Use the search box above to find a word. Select a result to see its details here.</p>
                  </div>
              );
          }
          return (
               <div className="h-[250px] rounded-2xl p-8 flex flex-col justify-center items-center text-center bg-gradient-to-br from-[#81d4fa] to-[#4fc3f7] text-white shadow-lg">
                  <div className="text-6xl mb-4">{card.icon || '📝'}</div>
                  <h3 className="text-3xl font-bold">{card.word}</h3>
                  <p className="text-xl mt-2 text-[#4361ee] font-bold font-['Tahoma']" dir="rtl">{card.arabicMeaning}</p>
                  <p className="text-md mt-4 text-white/90">{card.description}</p>
              </div>
          );
      };
      const SearchView = ({ cards }) => {
          const [searchTerm, setSearchTerm] = useState('');
          const [searchLang, setSearchLang] = useState('en');
          const [selectedCard, setSelectedCard] = useState(null);

          const filteredCards = useMemo(() => {
              if (!searchTerm) return [];
              try {
                  const regex = new RegExp(searchTerm.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&').replace(/\*/g, '.*'), 'i');
                  const searchKey = searchLang === 'en' ? 'word' : 'arabicMeaning';
                  return cards.filter(card => regex.test(card[searchKey]));
              } catch (e) {
                  return [];
              }
          }, [searchTerm, searchLang, cards]);

          return (
              <div className="bg-white p-6 rounded-2xl shadow-md">
                  <div className="mb-4 text-center">
                       <div className="inline-flex bg-gray-100 p-1 rounded-full mb-4">
                          <button 
                              className={`px-6 py-2 rounded-full font-semibold transition ${searchLang === 'en' ? 'bg-[#4361ee] text-white' : ''}`}
                              onClick={() => setSearchLang('en')}
                          >
                              Search English
                          </button>
                          <button 
                              className={`px-6 py-2 rounded-full font-semibold transition ${searchLang === 'ar' ? 'bg-[#4361ee] text-white' : ''}`}
                              onClick={() => setSearchLang('ar')}
                          >
                              Search Arabic
                          </button>
                      </div>
                      <input
                          type="text"
                          value={searchTerm}
                          onChange={(e) => setSearchTerm(e.target.value)}
                          placeholder={searchLang === 'en' ? 'Search words (use * for wildcard)...' : 'ابحث بالكلمات العربية (استخدم * للبحث)...'}
                          dir={searchLang === 'ar' ? 'rtl' : 'ltr'}
                          className="w-full text-lg p-3 border-2 border-[#4cc9f0] rounded-lg focus:ring-2 focus:ring-[#4361ee] transition"
                      />
                  </div>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6 items-start">
                      <div className="max-h-80 overflow-y-auto border border-gray-200 rounded-lg p-2">
                          {searchTerm && filteredCards.length === 0 && (
                              <div className="p-3 text-gray-500">No results found.</div>
                          )}
                          {filteredCards.map((card, index) => (
                              <div
                                  key={`${card.word}-${index}`}
                                  className="p-3 rounded-md cursor-pointer hover:bg-blue-100"
                                  style={{direction: searchLang === 'ar' ? 'rtl' : 'ltr'}}
                                  onClick={() => setSelectedCard(card)}
                              >
                                  {searchLang === 'en' ? card.word : card.arabicMeaning}
                              </div>
                          ))}
                      </div>
                      <div>
                          <SearchResultCard card={selectedCard} />
                      </div>
                  </div>
              </div>
          );
      };

      // from: components/QuizView.tsx
      const shuffleArray = (array) => {
          return [...array].sort(() => Math.random() - 0.5);
      }
      const QuizView = ({ cards, showNotification }) => {
          const [status, setStatus] = useState('level_select');
          const [level, setLevel] = useState(1);
          const [quizLength, setQuizLength] = useState(Math.min(20, cards.length));
          const [questions, setQuestions] = useState([]);
          const [currentIndex, setCurrentIndex] = useState(0);
          const [score, setScore] = useState(0);
          const [answered, setAnswered] = useState(null);

          const startQuiz = useCallback((selectedLevel) => {
              if (quizLength < 4) {
                  showNotification('Quiz must have at least 4 questions.', true);
                  return;
              }
              setLevel(selectedLevel);
              const shuffledCards = shuffleArray(cards);
              const quizCards = shuffledCards.slice(0, quizLength);
              const newQuestions = quizCards.map(qCard => {
                  let correctAnswer;
                  let options = new Set();
                  let distractorPool;
                  if (selectedLevel === 1) {
                      correctAnswer = qCard.arabicMeaning;
                      options.add(correctAnswer);
                      distractorPool = shuffleArray(cards.map(c => c.arabicMeaning).filter(m => m !== correctAnswer));
                  } else {
                      correctAnswer = qCard.word;
                      options.add(correctAnswer);
                      distractorPool = shuffleArray(cards.map(c => c.word).filter(w => w !== correctAnswer));
                  }
                  while(options.size < 4 && distractorPool.length > 0) {
                      options.add(distractorPool.pop());
                  }
                  return {
                      questionCard: qCard,
                      options: shuffleArray(Array.from(options)),
                      correctAnswer: correctAnswer
                  };
              });
              setQuestions(newQuestions);
              setCurrentIndex(0);
              setScore(0);
              setAnswered(null);
              setStatus('in_progress');
          }, [cards, quizLength, showNotification]);

          const handleAnswer = (selectedOption) => {
              setAnswered(selectedOption);
              if (selectedOption === questions[currentIndex].correctAnswer) {
                  setScore(prev => prev + 1);
                  showNotification('Correct!', false);
              } else {
                  showNotification('Incorrect!', true);
              }
              setTimeout(() => {
                  if (currentIndex < questions.length - 1) {
                      setCurrentIndex(prev => prev + 1);
                      setAnswered(null);
                  } else {
                      setStatus('finished');
                  }
              }, 2000);
          };

          const restartQuiz = () => {
              setStatus('level_select');
          };

          const currentQuestion = useMemo(() => questions[currentIndex], [questions, currentIndex]);

          if (status === 'level_select') {
              return (
                  <div className="bg-white p-6 rounded-2xl shadow-md text-center">
                      <h2 className="text-3xl font-bold mb-4">Select Quiz Level</h2>
                      <div className="mb-6">
                          <label htmlFor="quizLengthInput" className="text-xl mr-2">Number of Questions:</label>
                          <input 
                              type="number" 
                              id="quizLengthInput" 
                              value={quizLength}
                              onChange={e => setQuizLength(Math.min(cards.length, parseInt(e.target.value) || 4))}
                              min="4"
                              max={cards.length}
                              className="w-24 p-2 text-xl text-center border-2 border-[#4cc9f0] rounded-lg"
                          />
                      </div>
                      <div className="flex flex-col gap-4 max-w-sm mx-auto">
                          <button onClick={() => startQuiz(1)} className="btn-quiz bg-[#67cbf3]">Level 1: Word ➔ Meaning</button>
                          <button onClick={() => startQuiz(2)} className="btn-quiz bg-[#4361ee]">Level 2: Description ➔ Word</button>
                      </div>
                  </div>
              );
          }
          
          if (status === 'finished') {
               const percentage = Math.round((score / questions.length) * 100);
               let stars = '', icon = '';
               if (percentage >= 90) { stars = '⭐⭐⭐'; icon = '🏆'; } 
               else if (percentage >= 70) { stars = '⭐⭐'; icon = '🥇'; } 
               else if (percentage >= 50) { stars = '⭐'; icon = '👍'; } 
               else { stars = 'Try Again!'; icon = '😔'; }

              return (
                  <div className="bg-white p-6 rounded-2xl shadow-md text-center">
                      <div className="text-6xl mb-4">{icon}</div>
                      <h2 className="text-4xl font-bold mb-2">Quiz Complete!</h2>
                      <p className="text-2xl mb-4">Your final score is {score} out of {questions.length} ({percentage}%)</p>
                      <div className="text-5xl mb-6">{stars}</div>
                      <button onClick={restartQuiz} className="btn-quiz bg-[#f44336]"><RestartIcon /> New Quiz</button>
                  </div>
              )
          }

          if (!currentQuestion) return null;

          const { questionCard, options, correctAnswer } = currentQuestion;

          const getButtonClass = (option) => {
              if (!answered) return 'bg-white text-[#4361ee] hover:bg-[#4361ee] hover:text-white';
              if (option === correctAnswer) return 'bg-green-500 text-white border-green-500';
              if (option === answered) return 'bg-red-500 text-white border-red-500';
              return 'bg-gray-200 text-gray-500 border-gray-200 cursor-not-allowed';
          };

          return (
              <div className="bg-white p-6 rounded-2xl shadow-md">
                  <div className="flex justify-between items-center mb-4 text-lg font-bold">
                      <div>Question: {currentIndex + 1} / {questions.length}</div>
                      <div className="flex items-center gap-2"><ScoreIcon /> Score: {score}/{questions.length}</div>
                      <button onClick={restartQuiz} className="flex items-center gap-2 px-4 py-2 text-sm text-white bg-[#f44336] rounded-full hover:bg-red-700 transition"><RestartIcon /> Restart</button>
                  </div>
                  
                  <div className="text-center mb-6 min-h-[120px] flex flex-col justify-center">
                      {level === 1 ? (
                          <>
                              <div className="text-5xl mb-2">{questionCard.icon || '📝'}</div>
                              <h3 className="text-4xl font-bold">{questionCard.word}</h3>
                          </>
                      ) : (
                          <p className="text-2xl">{questionCard.description}</p>
                      )}
                  </div>

                  <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                      {options.map(option => (
                          <button
                              key={option}
                              onClick={() => handleAnswer(option)}
                              disabled={!!answered}
                              dir={level === 1 ? 'rtl' : 'ltr'}
                              className={`w-full p-4 text-xl font-semibold border-2 border-[#4361ee] rounded-lg transition-colors duration-300 disabled:opacity-70 ${getButtonClass(option)}`}
                          >
                              {option}
                          </button>
                      ))}
                  </div>
              </div>
          );
      };

      // from: components/GamesView.tsx
      const MatchingGame = ({ cards, onBack, showNotification }) => {
          const [gameCards, setGameCards] = useState([]);
          const [words, setWords] = useState([]);
          const [meanings, setMeanings] = useState([]);
          const [selectedWord, setSelectedWord] = useState(null);
          const [selectedMeaning, setSelectedMeaning] = useState(null);
          const [matchedPairs, setMatchedPairs] = useState([]);
          const [score, setScore] = useState(0);

          const setupGame = useCallback(() => {
              const GAME_SIZE = 8;
              if (cards.length < GAME_SIZE) {
                  showNotification(`You need at least ${GAME_SIZE} cards to play.`, true);
                  onBack();
                  return;
              }
              const shuffled = shuffleArray(cards).slice(0, GAME_SIZE);
              const gc = shuffled.map(c => ({ word: c.word, meaning: c.arabicMeaning, id: c.word }));
              setGameCards(gc);
              setWords(shuffleArray(gc.map(c => ({ text: c.word, id: c.id }))));
              setMeanings(shuffleArray(gc.map(c => ({ text: c.meaning, id: c.id }))));
              setScore(0);
              setMatchedPairs([]);
              setSelectedWord(null);
              setSelectedMeaning(null);
          }, [cards, onBack, showNotification]);

          useEffect(() => {
              setupGame();
          }, [setupGame]);

          useEffect(() => {
              if (selectedWord && selectedMeaning) {
                  const board = document.getElementById('matchBoard');
                  if (board) board.style.pointerEvents = 'none';
                  if (selectedWord.id === selectedMeaning.id) {
                      setMatchedPairs(prev => [...prev, selectedWord.id]);
                      setScore(s => s + 1);
                      showNotification('Match found!', false);
                      selectedWord.el.classList.add('correct');
                      selectedMeaning.el.classList.add('correct');
                      setSelectedWord(null);
                      setSelectedMeaning(null);
                       if (board) board.style.pointerEvents = 'auto';
                  } else {
                      selectedWord.el.classList.add('incorrect');
                      selectedMeaning.el.classList.add('incorrect');
                      setTimeout(() => {
                          selectedWord.el.classList.remove('selected', 'incorrect');
                          selectedMeaning.el.classList.remove('selected', 'incorrect');
                          setSelectedWord(null);
                          setSelectedMeaning(null);
                          if (board) board.style.pointerEvents = 'auto';
                      }, 800);
                  }
              }
          }, [selectedWord, selectedMeaning, showNotification]);

          useEffect(() => {
              if(gameCards.length > 0 && matchedPairs.length === gameCards.length) {
                  showNotification('🎉 Congratulations! You found all matches!', false);
              }
          }, [matchedPairs, gameCards.length, showNotification])

          const handleItemClick = (e, type, id) => {
              const el = e.currentTarget;
              if (el.classList.contains('correct')) return;
              if (type === 'word') {
                  if(selectedWord) selectedWord.el.classList.remove('selected');
                  el.classList.add('selected');
                  setSelectedWord({ el, id });
              } else {
                  if(selectedMeaning) selectedMeaning.el.classList.remove('selected');
                  el.classList.add('selected');
                  setSelectedMeaning({ el, id });
              }
          };
          
          return (
              <div>
                  <div className="flex justify-between items-center mb-4">
                      <span className="text-xl font-bold flex items-center gap-2"><ScoreIcon /> Score: {score}</span>
                      <button onClick={setupGame} className="btn-game bg-[#f44336]"><RestartIcon /> New Game</button>
                  </div>
                  <div id="matchBoard" className="grid grid-cols-2 gap-4">
                      <div className="flex flex-col gap-2">
                          {words.map(w => <div key={w.id} onClick={(e) => handleItemClick(e, 'word', w.id)} className="match-item">{w.text}</div>)}
                      </div>
                      <div className="flex flex-col gap-2">
                          {meanings.map(m => <div key={m.id} onClick={(e) => handleItemClick(e, 'meaning', m.id)} dir="rtl" className="match-item">{m.text}</div>)}
                      </div>
                  </div>
              </div>
          );
      };
      const HangmanGame = ({ cards, onBack, showNotification }) => {
          const [wordToGuess, setWordToGuess] = useState(null);
          const [guessedLetters, setGuessedLetters] = useState(new Set());
          const [wrongGuesses, setWrongGuesses] = useState(0);
          const MAX_WRONG = 6;
          
          const setupGame = useCallback(() => {
              const validWords = cards.filter(c => !c.word.includes(' ') && /^[A-Z]+$/i.test(c.word));
              if (validWords.length === 0) {
                  showNotification("No single-word cards available for Hangman.", true);
                  onBack();
                  return;
              }
              setWordToGuess(shuffleArray(validWords)[0]);
              setGuessedLetters(new Set());
              setWrongGuesses(0);
          }, [cards, onBack, showNotification]);

          useEffect(setupGame, [setupGame]);

          const wordLetters = wordToGuess?.word.toUpperCase().split('') || [];
          const isWon = wordLetters.every(letter => guessedLetters.has(letter));
          const isLost = wrongGuesses >= MAX_WRONG;
          const isGameOver = isWon || isLost;

          useEffect(() => {
              if(isWon) showNotification(`🎉 You won! The word was ${wordToGuess?.word}.`, false);
              if(isLost) showNotification(`😭 You lost. The word was: ${wordToGuess?.word}.`, true);
          }, [isWon, isLost, wordToGuess, showNotification]);

          const handleGuess = (letter) => {
              if (isGameOver) return;
              const upperLetter = letter.toUpperCase();
              setGuessedLetters(prev => new Set(prev).add(upperLetter));
              if (!wordToGuess?.word.toUpperCase().includes(upperLetter)) {
                  setWrongGuesses(prev => prev + 1);
              }
          };

          return (
              <div className="text-center">
                  <div className="flex justify-between items-center mb-2">
                      <span className="text-xl font-bold">Lives: {MAX_WRONG - wrongGuesses}</span>
                       <button onClick={setupGame} className="btn-game bg-[#f44336]"><RestartIcon /> New Game</button>
                  </div>
                  <HangmanDrawing numberOfGuesses={wrongGuesses} />
                  <div className="flex justify-center gap-2 mb-4 flex-wrap">
                      {wordLetters.map((letter, i) => (
                          <span key={i} className="w-10 h-10 border-b-4 border-[#4361ee] flex items-center justify-center text-3xl font-bold">
                              {(guessedLetters.has(letter) || isLost) && letter}
                          </span>
                      ))}
                  </div>
                  {!isGameOver && (
                      <div className="flex flex-wrap justify-center gap-2 max-w-lg mx-auto">
                          {'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').map(key => (
                              <button 
                                  key={key} 
                                  onClick={() => handleGuess(key)} 
                                  disabled={guessedLetters.has(key)}
                                  className="w-10 h-10 text-lg rounded-md border bg-gray-100 disabled:opacity-50"
                              >
                                  {key}
                              </button>
                          ))}
                      </div>
                  )}
              </div>
          );
      };
      const WordScrambleGame = ({ cards, onBack, showNotification }) => {
          const [currentCard, setCurrentCard] = useState(null);
          const [scrambledWord, setScrambledWord] = useState('');
          const [guess, setGuess] = useState('');
          const [score, setScore] = useState(0);
          const [isAnswered, setIsAnswered] = useState(false);

          const setupNextWord = useCallback(() => {
              const card = shuffleArray(cards)[0];
              setCurrentCard(card);
              let word = card.word;
              let scrambled = shuffleArray(word.split('')).join('');
              while (scrambled.toLowerCase() === word.toLowerCase() && word.length > 1) {
                  scrambled = shuffleArray(word.split('')).join('');
              }
              setScrambledWord(scrambled);
              setGuess('');
              setIsAnswered(false);
          }, [cards]);

          useEffect(setupNextWord, [setupNextWord]);

          const handleSubmit = () => {
              if (!guess || !currentCard) return;
              setIsAnswered(true);
              if (guess.trim().toLowerCase() === currentCard.word.toLowerCase()) {
                  showNotification(`✅ Correct! The word was ${currentCard.word}.`, false);
                  setScore(s => s + 1);
              } else {
                  showNotification(`❌ Incorrect. The word was: ${currentCard.word}.`, true);
              }
              setTimeout(setupNextWord, 3000);
          };

          const handleSkip = () => {
              setIsAnswered(true);
              showNotification(`The word was: ${currentCard?.word}.`, false);
              setTimeout(setupNextWord, 3000);
          };
          
          return(
              <div className="text-center">
                  <div className="flex justify-between items-center mb-4">
                      <span className="text-xl font-bold flex items-center gap-2"><ScoreIcon /> Score: {score}</span>
                      <button onClick={setupNextWord} className="btn-game bg-[#f44336]"><RestartIcon /> New Game</button>
                  </div>
                  <div className="text-5xl font-bold tracking-widest text-[#4361ee] my-6 p-5 bg-blue-50 rounded-lg">{scrambledWord}</div>
                  <input 
                      type="text" 
                      value={guess}
                      onChange={e => setGuess(e.target.value)}
                      disabled={isAnswered}
                      onKeyUp={e => e.key === 'Enter' && handleSubmit()}
                      className="w-full max-w-md p-3 text-2xl border-2 border-[#4cc9f0] rounded-lg text-center"
                  />
                  <div className="mt-4 flex justify-center gap-4">
                      <button onClick={handleSubmit} disabled={isAnswered} className="btn-game bg-[#67cbf3]">Submit</button>
                      <button onClick={handleSkip} disabled={isAnswered} className="btn-game bg-[#ff9f1c]">Skip</button>
                  </div>
              </div>
          );
      };
      const GamesView = ({ cards, showNotification }) => {
          const [activeGame, setActiveGame] = useState('menu');

          const renderGame = () => {
              switch (activeGame) {
                  case 'matching':
                      return <MatchingGame cards={cards} onBack={() => setActiveGame('menu')} showNotification={showNotification}/>;
                  case 'hangman':
                      return <HangmanGame cards={cards} onBack={() => setActiveGame('menu')} showNotification={showNotification}/>;
                  case 'scramble':
                      return <WordScrambleGame cards={cards} onBack={() => setActiveGame('menu')} showNotification={showNotification}/>;
                  default:
                      return (
                          <div className="text-center">
                              <h2 className="text-3xl font-bold mb-6">Vocabulary Games</h2>
                              <div className="flex flex-col gap-4 max-w-sm mx-auto">
                                  <button onClick={() => setActiveGame('matching')} className="btn-game bg-[#67cbf3]">Matching Game</button>
                                  <button onClick={() => setActiveGame('hangman')} className="btn-game bg-[#ff9f1c]">Hangman</button>
                                  <button onClick={() => setActiveGame('scramble')} className="btn-game bg-[#4cc9f0]">Word Scramble</button>
                              </div>
                          </div>
                      );
              }
          };

          return (
              <div className="bg-white p-6 rounded-2xl shadow-md min-h-[400px]">
                  {activeGame !== 'menu' && (
                       <button onClick={() => setActiveGame('menu')} className="mb-4 text-[#4361ee] font-semibold hover:underline">
                          &larr; Back to Games Menu
                       </button>
                  )}
                  {renderGame()}
              </div>
          );
      };

      // from: App.tsx
      const Header = () => (
          <header className="text-center mb-5 bg-[#4b1cf9] p-5 rounded-2xl text-white shadow-lg">
              <h1 className="text-4xl font-bold mb-2">Interactive English Flashcards</h1>
              <p className="text-lg opacity-90">Developed by Dr. Mazen Badawy – Doctorate of English Teaching and Testing</p>
          </header>
      );
      const ModeSelector = ({ activeMode, onModeChange, disabled }) => {
          const modes = [
              { id: 'memorize', label: 'Memorize', icon: <BookOpenIcon /> },
              { id: 'search', label: 'Search', icon: <SearchIcon /> },
              { id: 'quiz', label: 'Quiz', icon: <QuizIcon /> },
              { id: 'games', label: 'Games', icon: <GamepadIcon /> },
          ];
          const getModeButtonClass = (mode) =>
              `flex-1 p-3 rounded-full border-none font-bold cursor-pointer transition-all duration-300 flex items-center justify-center gap-2 text-lg ${
                  activeMode === mode
                      ? 'bg-[#4b1cf9] text-white shadow-md'
                      : 'bg-transparent text-[#4b1cf9]'
              } ${disabled ? 'opacity-50 cursor-not-allowed' : 'hover:bg-[#4b1cf9]/20'}`;

          return (
              <div className="bg-white p-2.5 rounded-full mb-5 flex gap-2.5 shadow-md">
                  {modes.map(mode => (
                      <button
                          key={mode.id}
                          className={getModeButtonClass(mode.id)}
                          onClick={() => !disabled && onModeChange(mode.id)}
                          disabled={disabled}
                      >
                          {mode.icon}
                          <span>{mode.label}</span>
                      </button>
                  ))}
              </div>
          );
      };
      function App() {
          const [flashcards, setFlashcards] = useState([]);
          const [currentMode, setCurrentMode] = useState('memorize');
          const [notification, setNotification] = useState(null);

          const showNotification = useCallback((message, isError = false) => {
              setNotification({ message, isError, key: Date.now() });
          }, []);
          
          const handleCardsLoaded = (cards) => {
              setFlashcards(cards);
              if (cards.length > 0) {
                  showNotification(`✅ Loaded ${cards.length} cards successfully!`);
              }
          };
          
          const renderCurrentView = () => {
              if (flashcards.length === 0) return null;
              
              switch (currentMode) {
                  case 'memorize':
                      return <MemorizeView cards={flashcards} setCards={setFlashcards} showNotification={showNotification} />;
                  case 'search':
                      return <SearchView cards={flashcards} />;
                  case 'quiz':
                      return <QuizView cards={flashcards} showNotification={showNotification}/>;
                  case 'games':
                      return <GamesView cards={flashcards} showNotification={showNotification}/>;
                  default:
                      return null;
              }
          }

          return (
              <div className="container mx-auto p-5 max-w-4xl">
                  <Header />
                  <section className="bg-white p-6 rounded-2xl mb-5 shadow-md text-center">
                      <FileLoader onCardsLoaded={handleCardsLoaded} showNotification={showNotification} />
                  </section>
                  {flashcards.length > 0 && (
                       <ModeSelector activeMode={currentMode} onModeChange={setCurrentMode} disabled={false} />
                  )}
                  <main>
                      {renderCurrentView()}
                  </main>
                  <Notification notification={notification} onClear={() => setNotification(null)} />
              </div>
          );
      }

      // from: index.tsx
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  </body>
</html>
